//#1 

// виведення start
console.log('start');

// створення промісу
const promise1 = new Promise((resolve, reject) => {
// виведення в консоль 1
console.log(1)
// вирішення промісу з записом результату 2
resolve(2)
})

// запис в callback queue стрілкової функції
promise1.then(res => {
// виведення в консоль 2 (з минулого промісу)
console.log(res)
})

// виведення end
console.log('end');

// запуск стрілкової функції з callback queue після того як stack стане пустим

//result: start -> 1 -> end -> 2

//#2

// створення вирішеного промісу з результатом 1
Promise.resolve(1)
		//створюється проміс, приймає 1 повертає 2
		.then((x) => x + 1)
		//створюється проміс, після виконання попереднього приймає 2 повертає повертає помилку
		.then((x) => { throw new Error('My Error') })
		//ловить помилку, створює проміс, повертає 1
		.catch(() => 1)
		//створюється проміс, приймає 1 повертає 2
		.then((x) => x + 1)
		//створюється проміс, приймає 2 виводить 2 у консоль
		.then((x) => console.log(x))
		// помилок не було тому ігнорується
		.catch(console.error)

//result: 2

//#3

//створюється проміс, вирішується з результатом 2, записується в константу promise
const promise = new Promise(res => res(2));
	//створюється проміс, приймає 2, виводить 2 в консоль, повертає 4
	promise.then(v => {
	        console.log(v);
	        return v * 2;
	    })
		//створюється проміс, приймає 4, виводить 4 в консоль, повертає 8
	    .then(v => {
	        console.log(v);
	        return v * 2;
	    })
		//цей метод нічого не приймає тому виведе underfind, також він нічого не повертає
	    .finally(v => {
	        console.log(v);
	        return v * 2;
	    })
		//створюється проміс, приймає 8 з попереднього then, виводить 8 в консоль 
	    .then(v => {
	        console.log(v);
	    });

//result: 2 -> 4 -> underfind -> 8